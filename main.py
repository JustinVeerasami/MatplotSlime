import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from time import time

# Optional allows you to save a simulation as a GIF
#from matplotlib.animation import PillowWriter

class PhysarumSim:
    def __init__(self, gridSize=100, numIterations=1000, batch_size=50, decay_rate=0.99, food_attraction_radius=15, food_lifetime=1.0):
        self.grid_size = gridSize
        self.num_iterations = numIterations
        self.batch_size = batch_size
        self.decay_rate = decay_rate
        self.food_attraction_radius = food_attraction_radius
        self.food_lifetime = food_lifetime  # Lifetime of food particle in seconds (allows the particle to disappear on time rather than before the animation reaches)
        self.grid = np.zeros((gridSize, gridSize))
        self.particles = np.zeros((gridSize, gridSize))
        self.foodParticles = []  # Store positions of food particles and their consumption times
        self.positions = []
        self.food_consumed_times = {}  # Dictionary to store consumption times of food particles
        self.food_to_remove = []  # List to store food particles to be removed
        self.fig, self.ax = plt.subplots()
        self.im = None  # To store the image plot for updating
        self.food_dots = None  # To store the plot of food particles

        # Connect mouse click to matplotlib for the mouse clicking to enable functions
        self.fig.canvas.mpl_connect('button_press_event', self.onclick)

# Section that entails the actual visual graph that will be generated by matplot
    def graphVisual(self):
        self.im = self.ax.imshow(self.grid, cmap='inferno', interpolation='nearest')
        self.food_dots, = self.ax.plot([], [], 'yo', markersize=10)  # Initialize food particles plot

        
        self.ax.set_title('Slime Mold (Physarum) Simulation')
        self.ax.get_xaxis().set_visible(False)
        self.ax.get_yaxis().set_visible(False)

        # Code (for graph formatting) pulled from chatGPT to maximize speed in finalizing the formatting of the project
        # Changes the graph background to a color slightly brighter than black
        self.fig.patch.set_facecolor('#141414')
        self.ax.set_facecolor('#141414')
        glow_color = '#614701'

        # Code that allows the graph to get a border to make it pop a bit more
        for spine in self.ax.spines.values():
            spine.set_edgecolor(glow_color)
            spine.set_linewidth(1)  # Thicker line for outer glow
            spine.set_alpha(0.7)     # Transparency for the outer glow
        
        self.ax.set_title('Slime Mold (Physarum) Simulation', color='white')

        # shifts color for the concentration bar to white and generates the actual bar
        cbar = self.fig.colorbar(self.im, ax=self.ax, label='Slime Mold Conc.')
        plt.setp(plt.getp(cbar.ax.axes, 'yticklabels'), color='white')  # Set tick labels to white
        cbar.ax.yaxis.label.set_color('white')  # Set the color of the label text to white

        # Use for limited animation frames
        #ani = FuncAnimation(self.fig, self.update_visualization, frames=self.num_iterations // self.batch_size, interval=100, repeat=False)

        # Use for indefinite animation
        ani = FuncAnimation(self.fig, self.update_visualization, interval=100, repeat= True)

        ### Save the animation as a .gif file within your hosted directory
        #writer = PillowWriter(fps=10)  # Adjust fps as needed
        #ani.save('animation.gif', writer=writer)

        plt.show()

# function that allows the visual frames of the graph to update along the selected iterations
    def update_visualization(self, frame):
        for _ in range(self.batch_size):
            self.updateParticles()
            self.decayParticles()
            self.checkFoodDecay()

        # Update food particles plot
        fx = [p[1] for p in self.foodParticles]
        fy = [p[0] for p in self.foodParticles]
        self.food_dots.set_data(fx, fy)

        # Update the grid and particles
        self.im.set_data(self.grid)  # Update the data for the image plot

        return self.im, self.food_dots

# Creates particles on the grid, a spread radius is implemented to slightly space them
# Spread avoids a weird glitch where they seem to freeze randomly if spawned directly centered
    def initParticles(self, num_particles=5, spread_radius=5, center=None):
        if center is None:
            center_x = self.grid_size // 2
            center_y = self.grid_size // 2
        else:
            center_x, center_y = center

        for _ in range(num_particles):
            # Introduce slight random spread around the center
            spread_x = np.random.randint(-spread_radius, spread_radius + 1)
            spread_y = np.random.randint(-spread_radius, spread_radius + 1)

            x = center_x + spread_x
            y = center_y + spread_y

            # Ensure positions are within grid bounds
            x = np.clip(x, 0, self.grid_size - 1)
            y = np.clip(y, 0, self.grid_size - 1)

            self.particles[x, y] = 1
            self.positions.append((x, y))
            self.grid[x, y] += 1  # Increment grid value for gradient effect

# Creates food particles randomly to start things off
# Food particles are on a different layer technically from the grid in order to assign diff colors
    def initFoodParticles(self, num_foodParticles=8):
        for _ in range(num_foodParticles):
            x, y = np.random.randint(self.grid_size), np.random.randint(self.grid_size)
            self.foodParticles.append((x, y))
            self.food_consumed_times[(x, y)] = None  # Initialize consumed time as None

# Section outlines the major movement patterns of the particles along the grid
    def movementPattern(self, x, y):
    # Check nearby food particles within the attraction radius
        min_dist = float('inf')
        best_dx, best_dy = 0, 0
     # Formula to determine the best travel route to a particle 
    # loops through the food particles on the grid to determine the traveling options
        for fx, fy in self.foodParticles:
        # Particular Important Formula detects the "Minimal Euclidean Distance"
            dist = np.sqrt((fx - x) ** 2 + (fy - y) ** 2)
            if dist < min_dist:
                min_dist = dist
                best_dx = fx - x
                best_dy = fy - y

        # If a food particle is within the attraction radius, move towards it
        # Otherwise, move randomly
        if min_dist <= self.food_attraction_radius:
            return np.sign(best_dx), np.sign(best_dy)
        else:
            return np.random.choice([-1, 0, 1]), np.random.choice([-1, 0, 1])

# Section allows for a movement towards nearby particles allowing clustering
    def moveCloserToOthers(self, x, y):
        # Find the closest particle and move towards it if too far away
        min_dist = float('inf')
        best_dx, best_dy = 0, 0
        for px, py in self.positions:
            if (px, py) != (x, y):
                # shortest euclidian distance formula
                dist = np.sqrt((px - x) ** 2 + (py - y) ** 2)
                if dist < min_dist:
                    min_dist = dist
                    best_dx = px - x
                    best_dy = py - y

        # If the closest particle is ___ or more units away, move towards it
        ## USE THIS TO EDIT CLUSTERING
        if min_dist >= 10:
            return np.sign(best_dx), np.sign(best_dy)
        else:
            return 0, 0  # No movement needed

# Rules that allow the particle to change its states as different scenarios occur
# tracks position, food, and animation time
    def updateParticles(self):
        new_positions = []
        consumed_food = []  # Track consumed food particles
        current_time = time()

        for pos in self.positions:
            x, y = pos
            # Determine movement direction based on food attraction and distance to other particles
            food_dx, food_dy = self.movementPattern(x, y)
            close_dx, close_dy = self.moveCloserToOthers(x, y)

            dx = food_dx + close_dx
            dy = food_dy + close_dy
         # avoids a default of matplot that allows particles to travel outside of grid   
            new_x = np.clip(x + dx, 0, self.grid_size - 1)  # Clamp x to grid boundaries
            new_y = np.clip(y + dy, 0, self.grid_size - 1)  # Clamp y to grid boundaries

            # Check if particle reaches a food particle
            if (new_x, new_y) in self.foodParticles:
                self.consumeFood(new_x, new_y, current_time)
                self.grid[new_x, new_y] += 1  # Increment grid at food location
                consumed_food.append((new_x, new_y))
            else:
                self.grid[new_x, new_y] += 1
                self.particles[new_x, new_y] = 1

            new_positions.append((new_x, new_y))

        self.positions = new_positions

        # Remove consumed food particles after updating positions
        for food in consumed_food:
            self.food_to_remove.append(food)

        # Clean up food particles marked for removal
        for food in self.food_to_remove:
            if food in self.foodParticles:
                self.foodParticles.remove(food)
                self.food_consumed_times.pop(food)
                self.grid[food[0], food[1]] = 0
            # Summon new particles around the consumed food location
            # Allows the reproduction of the slime via these particles which can be configured
                self.initParticles(num_particles=2, spread_radius=3, center=food)
        self.food_to_remove = []

    def consumeFood(self, x, y, current_time):
        # Record the consumption time of the food particle
        self.food_consumed_times[(x, y)] = current_time

    def decayParticles(self):
        self.particles *= self.decay_rate
        self.grid *= self.decay_rate

    def checkFoodDecay(self):
        current_time = time()
        for (fx, fy), consumed_time in list(self.food_consumed_times.items()):  # Use list() to avoid modifying while iterating
            if consumed_time is not None and current_time - consumed_time >= self.food_lifetime:
                self.food_to_remove.append((fx, fy))

        # Clean up food particles marked for removal
        for food in self.food_to_remove:
            if food in self.foodParticles:
                self.foodParticles.remove(food)
                self.food_consumed_times.pop(food)
                self.grid[food[0], food[1]] = 0
        self.food_to_remove = []

    def runSimulation(self):
        self.initParticles()
        self.initFoodParticles()

# Click rule that allows the intro of new food particles via left-click
# Portion of the functions that allows you to feed the mold
# Section built with the help of chatGPT due to difficulties in finding documentation for implementation
    def onclick(self, event):
        # Check if click happened within the plot area
        if event.xdata is not None and event.ydata is not None:
            # Convert clicked coordinates to grid indices
            x = int(event.xdata + 0.5)
            y = int(event.ydata + 0.5)

            # Ensure coordinates are within grid bounds
            if 0 <= x < self.grid_size and 0 <= y < self.grid_size:
                # Add food particle to the clicked location
                self.foodParticles.append((y, x))  # Note: Reversed due to imshow() displaying matrix transpose
                self.food_consumed_times[(y, x)] = None  # Initialize consumption time as None
                self.grid[y, x] += 1  # Increment grid at food location

                # Update the plot with the new food particle
                self.food_dots.set_data([p[1] for p in self.foodParticles], [p[0] for p in self.foodParticles])
                self.im.set_data(self.grid)
                self.fig.canvas.draw()

# configurable parameters to allow a new simulation each time the code is run
# Decay of 0.999 resembles a real mold very closely, but it doesn't look as fast paced, a decay of 0.99 keeps things quick for a demo

# A Faster paced version of the simulation, not as accurate, but much more interactive
#sim = PhysarumSim(gridSize=150, numIterations=1500, batch_size=50, decay_rate=0.99, food_attraction_radius=15, food_lifetime=1.0)

#Looks similar to a real mold, MOST ACCURATE PARAMETERS, laggier
sim = PhysarumSim(gridSize=150, numIterations=1500, batch_size=60, decay_rate=0.999, food_attraction_radius=15, food_lifetime=5.0)

# initiates the actual particles upon receiving the parameters above
sim.runSimulation()

# Initiates the actual animation upon having the initializations before
sim.graphVisual()
